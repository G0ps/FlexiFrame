# UI Schema & Interpreter — comprehensive summary

This document describes the schema-driven UI model and the interpreter/engine we built. It explains the schema shape, how the interpreter compiles and runs logic, event wiring, data typing, networking helpers, execution flow, examples, security considerations, validation suggestions and extension points.

---

# 1. High-level purpose

A **declarative, JSON-driven UI system** that:

* Defines UI structure (pure HTML elements), CSS, and executable logic in a single schema.
* Compiles function `logic` into **real JavaScript functions** stored in a global registry (`FUNCTIONS_SET` / `ALL_FUNCTIONS`).
* Renders DOM (no React, no JSX) and injects CSS at runtime.
* Binds events to compiled functions, passing typed parameters extracted from the DOM.
* Supports nested function calls (logic may call other registered functions).
* Includes a generic HTTP helper layer (`doGet`, `doPost`, `doPut`, `doPatch`, `doDelete`) with sensible defaults.

This is suitable for dynamic UIs driven by remote schemas, quick iteration, low-footprint pages, or CMS-driven frontends.

---

# 2. Schema shape (top-level)

```json
{
  "functions": [ /* compiled to FUNCTIONS_SET */ ],
  "elements": [ /* declarative DOM tree */ ],
  "css": [ /* list of selector+rules blocks */ ]
}
```

## 2.1 `functions` item (required fields)

```json
{
  "function_id": "unique-id",
  "name": "optionalName",
  "params": [
    { "name": "p1", "type": "number" }
  ],
  "logic": "/* JS code executed in strict mode */"
}
```

* `function_id`: registry key used by events and other functions.
* `params`: ordered parameter list (name & type mandatory).

  * Allowed types: `number`, `string`, `boolean`, `element`, `object`, `array` (extendable).
* `logic`: raw JS body (not a serialized/remote evaluator). It is wrapped in `"use strict";` and compiled via `new Function(...params, logic)`.

### Nested calls

* Logic may call other functions via the registry:

  ```js
  const a = ALL_FUNCTIONS['parse_num'](rawA);
  const result = ALL_FUNCTIONS['multiply'](a, b);
  ```
* Because compiled functions are real JS functions in the same global runtime, nested calls are direct function calls.

## 2.2 `elements` item

Declarative DOM nodes with these fields:

```json
{
  "type": "div|button|input|p|h1|...",
  "id": "optional-id",
  "class": "css-class",
  "text": "textContent",
  "attributes": { "placeholder": "...", "type": "text" },
  "children": [ /* nested elements */ ],
  "events": [
    {
      "event": "click|change|input|submit",
      "function_id": "handle_fn",
      "params": [
        { "from": "element", "id": "fieldId", "extract": "value|text", "type": "number" }
      ]
    }
  ]
}
```

* Events reference `function_id` and a typed `params` array.
* The interpreter extracts, casts and passes params in the declared order.

## 2.3 `css` item

```json
{ "selector": ".my-class", "rules": "padding:8px; color:#222;" }
```

* Concise: selector and rules string. Engine concatenates and injects into a `<style>`.

---

# 3. Interpreter architecture — core components

1. **Schema loader**
   Accepts JSON schema (local variable, fetched from server, or via WebSocket).

2. **Function compiler**

   * For each `functions[]` item:

     * Build parameter list from `params`.
     * Wrap `logic` with `"use strict";` and compile via `new Function(...paramNames, wrappedLogic)`.
     * Store compiled function in `FUNCTIONS_SET[function_id]`.
   * Example compiled function:

     ```js
     FUNCTIONS_SET["sum"] = function(a,b) {
       "use strict";
       return a + b;
     }
     ```

3. **CSS injector**

   * Concatenate `css` blocks to a single string and set `styleTag.textContent`.

4. **DOM renderer**

   * Recursively create DOM nodes with `document.createElement(type)`.
   * Set `id`, `className`, `textContent`, and `attributes`.
   * Append children.

5. **Event binder & param extraction**

   * For each event:

     * On event, gather `params` (for each param: locate element, extract `value`/`text` and `castType(raw, declaredType)`).
     * Call `FUNCTIONS_SET[function_id](...castedParams)`.
   * `castType` supports conversion rules:

     * `number` → `Number(raw)` (NaN handling recommended)
     * `boolean` → `raw === 'true' || Boolean(raw)`
     * `string` → `String(raw)`
     * `element` → pass element reference (document.getElementById)
     * `object/array` → parse JSON if raw string

6. **Network helpers (global)**
   `doGet`, `doPost`, `doPut`, `doPatch`, `doDelete` using `fetch()` with sensible default headers:

   * `POST/PUT/PATCH` include `Content-Type: application/json` and `Accept: application/json` by default.
   * They return parsed `res.json()` (caller must handle network errors and non-JSON responses).

---

# 4. Example end-to-end schema (concise)

Sample schema with typed params and nested calls:

```json
{
  "functions": [
    { "function_id":"parse_num", "params":[{"name":"x","type":"string"}], "logic":"return Number(x);" },
    { "function_id":"mul", "params":[{"name":"a","type":"number"},{"name":"b","type":"number"}], "logic":"return a*b;" },
    { "function_id":"calc", "params":[{"name":"x","type":"string"},{"name":"y","type":"string"}],
      "logic": "const a=ALL_FUNCTIONS['parse_num'](x); const b=ALL_FUNCTIONS['parse_num'](y); return ALL_FUNCTIONS['mul'](a,b);"
    }
  ],
  "elements": [
    { "type":"input", "id":"A", "attributes":{"placeholder":"A"} },
    { "type":"input", "id":"B", "attributes":{"placeholder":"B"} },
    { "type":"button", "text":"Compute", "events":[{"event":"click","function_id":"calc","params":[{"from":"element","id":"A","extract":"value","type":"string"},{"from":"element","id":"B","extract":"value","type":"string"}]}] }
  ],
  "css": [ { "selector":"button","rules":"padding:8px 12px;" } ]
}
```

**Expected behavior**: clicking Compute calls `calc` → `parse_num` → `mul` and returns numerical product. Event handler can then write result into the DOM if a function updates a target element.

---

# 5. Runtime flow (step-by-step)

1. `renderUI(schema)` is called.
2. `compileFunctions(schema.functions)` builds and registers compiled functions into `FUNCTIONS_SET`.
3. `renderCSS(schema.css)` writes CSS into the page.
4. `createElement()` recursively builds DOM elements and attaches events.
5. When user triggers an event:

   * Interpreter extracts DOM values, casts them to declared types.
   * Calls compiled function from `FUNCTIONS_SET`.
   * If logic calls other functions, those calls resolve to existing entries in `FUNCTIONS_SET`.

---

# 6. Examples of function logic patterns

* **Simple pure function**

  ```js
  "logic": "return a + b;"
  ```
* **Nested call**

  ```js
  "logic": "const x=ALL_FUNCTIONS['parse_num'](a); return ALL_FUNCTIONS['mul'](x, 10);"
  ```
* **DOM-aware function**

  ```js
  "logic": "const el=document.getElementById('result'); el.textContent = 'OK'; return true;"
  ```
* **HTTP call inside function**

  ```js
  "logic": "return doPost('/api', {a:b});"
  ```

  * Note: `doPost` returns a promise — the calling event handler should `await` or handle promise if function is `async`. To support async logic, schema `logic` can use `return (async ()=>{ ... })();` or we can support `async` compilation (see extensions).

---

# 7. Important implementation details & constraints

### Strict mode

* All compiled functions include `"use strict";` to avoid accidental global leaks and enforce safer semantics.

### Functions stored as real functions (NOT strings)

* `FUNCTIONS_SET[id] = compiledFunction` — consumers call functions directly. This enables nested calls and better performance than text-evaluation later.

### Typed params

* Event-side params and function params are typed. Interpreter performs casting before calling functions.

### Event param ordering

* Ordering of `params` in event payload must match the expected parameter order of the target function.

### Synchronous vs asynchronous

* Current compilation uses `new Function(...)`. If schema logic needs `await`, either:

  * Provide functions that return promises (e.g., `return doPost(...).then(...)`), or
  * Support `async` functions by creating an async wrapper: `new Function(...params, '"use strict"; return (async function(){' + logic + '})()')`. Choose explicitly depending on runtime requirements.

### Error handling

* The basic interpreter logs missing functions or elements. Production-grade engine should add:

  * Try/catch around compiled function calls.
  * Fallback UI on errors.
  * Validation errors surfaced before runtime.

---

# 8. Security considerations

* **Arbitrary `logic` execution**: compiling raw `logic` from untrusted sources is potentially dangerous (XSS, exfiltration). Options:

  * Accept schema only from trusted servers.
  * Sanitize `logic` (very hard to do safely).
  * Run logic in a strictly sandboxed environment (iframe with CSP, or a web worker with a safe RPC surface).
  * Restrict allowed global names (expose a thin API object instead of `document` and `ALL_FUNCTIONS`).
* **Network calls**: functions can call `doPost` etc. Enforce CORS and origin rules server-side and throttle requests client-side if needed.
* **Validation**: validate schema shape and types before compiling.

---

# 9. Validation rules (recommended)

* Ensure every `function_id` is unique.
* Every `function.params` entry must have `name` and `type`.
* Every `element.events[].function_id` must reference an existing function.
* Event `params[].from` values: restrict to `element|literal|constant|global`.
* `attributes` keys must be safe attribute names.
* Limit function `logic` length and/or banned patterns (e.g., no `new Function` or `eval` inside logic).

---

# 10. Extension points / roadmap

1. **Async function support**: compile functions as `async` when schema indicates (e.g., `"async": true`).
2. **Sandboxing**: execute logic inside an iframe or worker; expose `ALL_FUNCTIONS` via RPC to limit surface area.
3. **Dynamic schema updates**: apply diffs and patch DOM instead of full rerender.
4. **Component reuse**: allow `elements` to declare templates and instances.
5. **Computed CSS & conditional classes**: rules that evaluate based on state.
6. **State store**: add a small global state object accessible to functions and UI.
7. **Schema versioning**: compatibility checks & migrations.
8. **Schema validator**: strict JSON Schema with helpful error messages.

---

# 11. Testing checklist

* Unit test: compiler creates functions matching param order and throws for missing params.
* Integration test: event -> param extraction -> cast types -> function called with expected values.
* End-to-end: provide a schema, render UI, simulate events in a headless browser, assert DOM updates.
* Security test: inject malicious `logic` and verify sandboxing and policy rules prevent data exfiltration.

---

# 12. Quick concrete example (schema → expected UI / behavior)

Schema (abridged):

```json
{
  "functions":[
    {"function_id":"parse_num","params":[{"name":"x","type":"string"}],"logic":"return Number(x);"},
    {"function_id":"sum","params":[{"name":"a","type":"number"},{"name":"b","type":"number"}],"logic":"return a+b;"},
    {"function_id":"show","params":[{"name":"txt","type":"string"}],"logic":"document.getElementById('out').textContent = txt;"}
  ],
  "elements":[
    {"type":"input","id":"A"},
    {"type":"input","id":"B"},
    {"type":"button","text":"Add",
      "events":[{"event":"click","function_id":"show","params":[
        {"from":"element","id":"A","extract":"value","type":"string"},
        {"from":"element","id":"B","extract":"value","type":"string"}
      ]}]
    },
    {"type":"p","id":"out","text":""}
  ],
  "css":[{"selector":"button","rules":"padding:8px;"}]
}
```

Expected runtime behavior:

* Click button → interpreter casts inputs as strings, `show` is invoked with string params.
* If `show` had instead called `ALL_FUNCTIONS['sum']` after `parse_num`, final `out` would show numeric sum.

---

# 13. Final notes

* The system is intentionally minimal and explicit: typed params, compiled real functions, DOM-first rendering, and a reusable HTTP layer.
* For production, add schema validation, sandboxing, error reporting, and async handling rules.
* I can produce:

  * A strict JSON Schema validator for the UI schema,
  * A sandbox design (iframe/worker) and secure API surface,
  * An async-enabled compiler variant,
  * A version that diffs and patches DOM for incremental updates.

Which of these would you like me to implement next?



errors_found
* Generate a schema-driven UI where each function’s logic is stored only as the function body string, without including the function keyword or declaration. All parameters must have their types explicitly defined. When interpreting the schema, the function body should be wrapped dynamically in an async arrow function or standard function, and registered in a global object like ALL_FUNCTIONS. Ensure that any await usage is allowed in the wrapper, and all DOM element values are correctly extracted based on the defined parameter types. Avoid embedding full function declarations in the logic field to prevent SyntaxError during dynamic compilation.