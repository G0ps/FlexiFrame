+++++++++++++++++++++++++++++++++++++++
PYTHON DICT ONLY RESPONSE (STRICT)

Fixed a async problem



UI Schema & Interpreter — Comprehensive Summary

This document describes the schema-driven UI model and the interpreter/engine. It explains the schema structure, function compilation with async handling, event wiring, parameter typing, networking helpers, execution flow, examples, validation, security considerations, and extension points.

1. High-level Purpose

A declarative, Python-dict-driven UI system that:

Defines UI structure (pure HTML elements), CSS, and executable logic in a single schema.

Compiles function logic into real async functions stored in a global registry (FUNCTIONS_SET / ALL_FUNCTIONS).

Renders DOM (no React, no JSX) and injects CSS at runtime.

Binds events to compiled functions, passing typed parameters extracted from the DOM.

Supports nested function calls (logic may call other registered functions).

Includes a generic HTTP helper layer (do_get, do_post, do_put, do_patch, do_delete) with sensible defaults.

This is suitable for dynamic UIs driven by remote schemas, low-footprint pages, or CMS-driven frontends.

2. Schema Shape (Top-Level)
{
    "functions": [  # compiled to FUNCTIONS_SET
    ],
    "elements": [  # declarative DOM tree
    ],
    "css": [  # list of selector+rules blocks
    ]
}

2.1 functions Item
{
    "function_id": "unique-id",
    "name": "optionalName",
    "params": [
        { "name": "p1", "type": "number" }
    ],
    "logic": "# Python async function body executed in strict mode"
}


function_id: registry key used by events and other functions.

params: ordered parameter list with explicit name and type.

Supported types: number, string, boolean, element, object, array.

logic: only the function body, not a full function declaration. The interpreter wraps it in an async function.

Nested Calls

Functions may call other registered functions via ALL_FUNCTIONS:

a = await ALL_FUNCTIONS['parse_num'](rawA)
result = await ALL_FUNCTIONS['multiply'](a, b)


Because compiled functions are real async functions, nested calls work naturally.

2.2 elements Item

Declarative DOM nodes:

{
    "type": "div|button|input|p|h1|...",
    "id": "optional-id",
    "class": "css-class",
    "text": "textContent",
    "attributes": { "placeholder": "...", "type": "text" },
    "children": [  # nested elements
    ],
    "events": [
        {
            "event": "click|change|input|submit",
            "function_id": "handle_fn",
            "params": [
                { "from": "element", "id": "fieldId", "extract": "value|text", "type": "number" }
            ]
        }
    ]
}


Events reference a function_id and a typed params array.

The interpreter extracts values from DOM, casts them to the declared type, and passes them to the function.

2.3 css Item
{ "selector": ".my-class", "rules": "padding:8px; color:#222;" }


Engine concatenates all rules and injects into a <style> tag at runtime.

3. Interpreter Architecture — Core Components

Schema Loader
Accepts a dict schema (local variable, fetched from server, or via WebSocket).

Function Compiler with Async Handling

def compile_functions(functions):
    for func in functions:
        param_names = [p["name"] for p in func["params"]]
        wrapped_logic = f"async def _tmp({', '.join(param_names)}):\n    {func['logic']}"
        ALL_FUNCTIONS[func["name"]] = wrapped_logic


Logic must contain only the function body, not async def(...){}.

Wrapper ensures await works.

Nested calls via ALL_FUNCTIONS remain valid.

CSS Injector
Concatenate css blocks and inject them into <style>.

DOM Renderer
Recursively create DOM nodes, set attributes, append children, and attach events.

Event Binder & Param Extraction

Event handlers are async:

async def handle_event(event):
    args = [extract_and_cast(p) for p in event["params"]]
    await ALL_FUNCTIONS[event["function_id"]](*args)


extract_and_cast(p) handles:

number → float(raw)

boolean → raw == 'true' or bool(raw)

string → str(raw)

element → DOM element reference

object/array → parse JSON

Network Helpers (Global Async)

async def do_post(url, body, headers=None):
    if headers is None:
        headers = {}
    headers.update({ "Content-Type": "application/json", "Accept": "application/json" })
    res = await fetch(url, method="POST", headers=headers, body=json.dumps(body))
    return await res.json()


Similarly: do_get, do_put, do_patch, do_delete.

Functions in schema can await do_post(...) or call do_get(...).

4. Example End-to-End Schema (Async Enabled)
{
    "functions": [
        { "function_id":"parse_num", "params":[{"name":"x","type":"string"}], "logic":"return float(x)" },
        { "function_id":"mul", "params":[{"name":"a","type":"number"},{"name":"b","type":"number"}], "logic":"return a*b" },
        { "function_id":"calc", "params":[{"name":"x","type":"string"},{"name":"y","type":"string"}],
          "logic": "a = await ALL_FUNCTIONS['parse_num'](x)\nb = await ALL_FUNCTIONS['parse_num'](y)\nreturn await ALL_FUNCTIONS['mul'](a,b)"
        }
    ],
    "elements": [
        { "type":"input", "id":"A", "attributes":{"placeholder":"A"} },
        { "type":"input", "id":"B", "attributes":{"placeholder":"B"} },
        { "type":"button", "text":"Compute",
          "events":[{"event":"click","function_id":"calc","params":[
            {"from":"element","id":"A","extract":"value","type":"string"},
            {"from":"element","id":"B","extract":"value","type":"string"}
          ]}]
        }
    ],
    "css": [ { "selector":"button","rules":"padding:8px 12px;"} ]
}


Clicking Compute triggers async chain: calc → parse_num → mul.

Output can be displayed in the DOM via a show function or additional element.

5. Runtime Flow (Step-by-Step)

render_ui(schema) is called.

compile_functions(schema["functions"]) builds async functions in ALL_FUNCTIONS.

render_css(schema["css"]) writes style rules.

create_element() recursively builds the DOM.

Event triggers:

Extract DOM values.

Cast values to declared types.

Call await ALL_FUNCTIONS[function_id](*args).

Nested calls execute within the same async runtime.

6. Function Logic Patterns

Simple pure function

"logic": "return a + b"


Nested async call

"logic": "x = await ALL_FUNCTIONS['parse_num'](a)\nreturn await ALL_FUNCTIONS['mul'](x, 10)"


DOM-aware

"logic": "document.getElementById('out').textContent = 'OK'"


HTTP inside function

"logic": "res = await do_post('/api', {'a':b})\ndocument.getElementById('out').textContent = json.dumps(res)"

7. Key Implementation Details

Strict mode: enforced in Python with async wrapper.

Functions stored as real functions: ALL_FUNCTIONS[id] = compiled_function.

Typed params: all event params are cast before passing.

Async support: wrapper allows await inside schema logic.

Error handling: try/except in function logic; interpreter should log missing functions or elements.

8. Security Considerations

Logic execution is potentially dangerous — only load trusted schemas.

Network requests must respect CORS and origin rules.

Optional sandboxing: iframe or worker to limit global access.

Validate schema shape, param types, and event bindings before compiling.

9. Validation Rules

function_id unique.

All params have name and type.

Events reference existing functions.

Event param from values: element|literal|constant|global.

Safe attribute names and CSS selectors.

Limit function logic length; prevent eval-like constructs inside logic.

10. Extension Points / Roadmap

Async function flag in schema ("async": True)

Sandboxed execution (iframe/worker)

Dynamic schema updates with DOM patching

Component templates and reuse

Conditional/computed CSS

Global state object

Schema versioning and migration

Schema validator with detailed errors

11. Testing Checklist

Unit: validate compilation and param order.

Integration: simulate events and verify async calls.

E2E: schema → UI → user actions → DOM changes.

Security: ensure sandboxing or trusted sources.

12. Concrete Example (Schema → Expected UI)
{
    "functions":[
        {"function_id":"parse_num","params":[{"name":"x","type":"string"}],"logic":"return float(x)"},
        {"function_id":"sum","params":[{"name":"a","type":"number"},{"name":"b","type":"number"}],"logic":"return a+b"},
        {"function_id":"show","params":[{"name":"txt","type":"string"}],"logic":"document.getElementById('out').textContent = txt"}
    ],
    "elements":[
        {"type":"input","id":"A"},
        {"type":"input","id":"B"},
        {"type":"button","text":"Add",
          "events":[{"event":"click","function_id":"show","params":[
            {"from":"element","id":"A","extract":"value","type":"string"},
            {"from":"element","id":"B","extract":"value","type":"string"}
          ]}]
        },
        {"type":"p","id":"out","text":""}
    ],
    "css":[{"selector":"button","rules":"padding:8px;"}]
}


Clicking button: inputs are cast, show is invoked.

If show calls async nested functions, await works correctly.

13. Summary Notes

System is minimal, typed, DOM-first, async-safe.

Compiles real async functions, handles nested calls, typed params, DOM extraction, and HTTP helpers.

Production improvements: schema validation, sandboxing, incremental DOM updates, async compiler variant.

This version resolves both:

SyntaxError: function statements require a function name

await is only valid in async functions

by storing only the function body in the schema and wrapping compiled functions in async functions.
+++++++++++++++++++++++++++++++++++++++



python version